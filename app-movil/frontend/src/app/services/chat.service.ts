import { HttpClient, HttpErrorResponse, HttpHeaders } from '@angular/common/http';
import { Injectable } from '@angular/core';
import { firstValueFrom, timeout } from 'rxjs';
import { DiagnosisContext } from './chat-context.service';
/**
 * ChatService
 *
 * Servicio responsable de enviar preguntas al backend y recibir
 * respuestas generadas por el modelo de lenguaje.
 *
 * Service responsible for sending questions to the backend
 * and receiving responses generated by the language model.
 */


export interface AskRecommendationRequest {
  question: string;
  context: DiagnosisContext;
}

export interface AskRecommendationResponse {
  ok: boolean;
  content: string;   // Markdown generado por el backend
  usage?: {
    promptTokens?: number;
    completionTokens?: number;
    totalTokens?: number;
    model?: string;
    latencyMs?: number;
  };
}
@Injectable({
  providedIn: 'root',
})
export class ChatService {
  private readonly BASE = 'http://localhost:5001';
  private readonly PATH = '/recommendation';
  private readonly TIMEOUT_MS = 45_000;
  constructor(private http: HttpClient) {}

  // Extractor flexible que soporta múltiples formatos de respuesta
  private extractMarkdown(res: any): string | null {
    if (res == null) return null;

    // 1) Texto plano
    if (typeof res === 'string') return res;

    // 2) { ok?, content }
    if (typeof res.content === 'string' && res.content.trim()) return res.content;

    // 3) { answer }
    if (typeof res.answer === 'string' && res.answer.trim()) return res.answer;

    // 4) Estilo OpenAI
    const oa = res?.choices?.[0]?.message?.content
            ?? res?.data?.choices?.[0]?.message?.content;
    if (typeof oa === 'string' && oa.trim()) return oa;

    // 5) { message } común
    if (typeof res.message === 'string' && res.message.trim()) return res.message;

    return null;
  }

  async askRecommendation(question: string, context: DiagnosisContext): Promise<string> {
    const url = `${this.BASE}${this.PATH}`;
    const payload: AskRecommendationRequest = { question: question.trim(), context };

    const headers = new HttpHeaders({ 'Content-Type': 'application/json' });

    try {
      const res = await firstValueFrom(
        this.http.post<any>(url, payload, { headers }).pipe(timeout(this.TIMEOUT_MS))
      );

      // Intentamos extraer contenido aunque no venga `ok:true`
      const md = this.extractMarkdown(res);
      if (md && md.trim()) return md;

      // Si explícitamente vino ok=false con mensaje, devuélvelo igual
      if (res && res.ok === false) {
        const fallback = this.extractMarkdown(res) ?? 'El servidor no envió contenido.';
        return fallback;
      }

      // Último recurso: serializar para inspección rápida
      return 'No se pudo interpretar la respuesta del servidor.';
    } catch (err) {
      const e = err as HttpErrorResponse | Error;

      // Si el servidor respondió error con cuerpo útil, intenta extraerlo
      if (e instanceof HttpErrorResponse) {
        const body = e.error;
        const extracted = this.extractMarkdown(body);
        if (extracted) return extracted; // devolvemos lo que haya para no romper el flujo
        // Mensaje genérico si no hay nada aprovechable
        return `Error del servidor (${e.status}): ${e.statusText || 'Solicitud fallida'}.`;
      }

      // Timeout u otros
      return e.message || 'Error desconocido al consultar recomendaciones.';
    }
  }
}
